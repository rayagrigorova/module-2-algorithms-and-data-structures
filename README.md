<h1 align="center">Задачи</h1>

## 1. Задачи

1. Проследете какво се случва в кода. Напишете итеративния вариант на този код.

```java
public static void main(String[] args) {
   	 System.out.println("Sum is " + xMethod(5));
}

public static int xMethod(int n) {
   	 if (n == 1)
   		 return 1;
   	 else
   		 return n + xMethod(n - 1);
}
```

2. Проследете какво се случва в кода. Напишете итеративния вариант на този код.

```java
public static void main(String[] args) {
   	 xMethod(1234567);
}

public static void xMethod(int n) {
   	 if (n > 0) {
   		 System.out.print(n % 10);
   		 xMethod(n / 10);
   	 }
 }
```

3. Напишете два метода, които намират 2n , където n е положително цяло число, въведено от потребителя. Единият метод да използва рекурсия, а другият итерация.
4. Напишете два метода, които намират xn , където n е положително цяло число, a x e реално число, въведени от потребителя. Единият метод да използва рекурсия, а другият итерация.

## 2. Задачи

1. Да предположим, че не сте в състояние да извършвате други операции с int стойности освен да ги намалявате или да ги сравнявате с 0 или 1. Напишете два рекурсивни метода odd (int x) и even (int x), които съответно da връщат дали x е нечетно или четно число. Предполагаме, че x >= 0.
2. Напишете рекурсивен метод, който преобразува десетично число в двоично число, представено като низ. Сигнатурата на метода е 
public static String dec2Bin ( int value )
3. Променете TowerOfHanoi.java, така че програмата да намери броят на ходовете, необходими за преместване на n дискове от кула A към кула C.


## 3. Задачи

Пълно условие:
[3. Задачи.pdf](https://github.com/rayagrigorova/module-2-algorithms-and-data-structures/files/12184367/3.pdf)

## 4. Задачи

1. Тествайте кода. Определете какво прави този опашен рекурсивен метод?

```java
    public static int foo (int x, int y)
    {
   	if (y == 0)
     	    return x;
   	else
     	    return foo(y, x % y);
    }
```

2. Оптимизирайте метода, използвайки опашна рекурсия

```java
public static void main(String[] args) {
   	 System.out.println("Sum is " + xMethod(5));
}

public static int xMethod(int n) {
   	 if (n == 1)
   		 return 1;
   	 else
   		 return n + xMethod(n - 1);
}
```

3. Оптимизирайте метода за повдигане на степен, използвайки опашна рекурсия

```java
    public static int powRecursive( int x, int n ) {
   	 if (n == 0) {
   		 return 1;
   	 }
   	 
   	 return x * powRecursive(x, n - 1 );
    }
```

4. Напишете опашен рекурсивен метод, който да пресмята средно аритметично на масив от цели числа

## 5. Задачи

1. Разгледайте класа GenericStack. Имплементирайте го с помощта на **масив**, а не на ArrayList. Трябва да проверите размера на масива преди да добавите нов елемент към стека. Ако масивът е пълен, създайте нов масив, който удвоява текущия размер на масива и копира елементите от текущия масив в нов масив. Започнете с начален размер на масива 3. Напишете тест програма, която подканва потребителя да въведе пет низа и ги показва в обратен ред. 

2. GenericStack е имплементиран с помощта на композиция. Дефинирайте нов клас стек, който **наследява ArrayList**. Напишете тест програма, която подканва потребителя да въведе пет низа и ги показва в обратен ред. 

## 6. Задачи

1. Променете класа GeometricObject и имплементирайте интерфейса Comparable, който да сравнява лицата на обектите. Тествайте GenericSort с няколко обекта от класа Circle и  Rectangle. Принтирайте сортирания масив. Обърнете внимание, че методът toString() трябва да се overrifde-не в Circle и  Rectangle, за да работи методът printList()
2. Имплементирайте трите метода, които разбъркват, сортират и намират минималния елемент на списък.

```java
public static <E> void shuffle(ArrayList<E> list)
public static <E extends Comparable<E>> void sort(ArrayList<E> list)
public static <E extends Comparable<E>> E min(ArrayList<E> list)
```
